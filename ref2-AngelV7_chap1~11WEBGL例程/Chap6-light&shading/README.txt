Chapter 6 Programs
-------------------------------------------------------------------------------------------------------------
！！！！其实无论在对象坐标下，还是在观察坐标下计算光照颜色都是可行的， 位置和颜色计算无关！！！！
！！！眼坐标计算时，观察向量的计算作了简化，因为原点（观察坐标的AT)，物体位置点，眼坐标在一条线上，所以-pos表示
！！！注意向量L, V(即E),N 三个向量参数的方向，都是从顶点位置向外的。可以出题考察

--------------------------------------------------------------------------------------------------------------
wireSphere: wire frame of recursively generated sphere
递归细分四棱锥，生成线框球。（传递各个顶点位置，统一模视矩阵，统一投影矩阵给shader)


-------------------------------------------------------------------------------------------------------------
shadedCube: rotating cube with modified Phong shading       
明暗着色的旋转立方体，四个按钮，三个控制X,Y,Z旋转轴，toggle停止旋转切换。法向量由每个三角形得三个顶点计算得到。  
----注意shadedCube中，视点在原点，WC，WC重合，模式变换矩阵其实只是模型变换矩阵。
    而光源在（1,1,1）。视点在立方体内，所以看起来有问题！！！
shadedCube-cr:
/**********************************************************************************************************
书6.8.3 在顶点着色器中实现光照计算
修改部分： 增加设置了视点变动，视点不在原点了，APP需要传递观察方向给shader。
           shader中的光照计算（顶点位置，顶点法向量需要先进行模型变换后再和不动光源入射向量和观察向量进行计算）		    
           shader中计算顶点新位置，模视变换不再只有模型变换，。APP中生成视点变换矩阵并传递给shader
***********************************************************************************************************/





--------------------------------------------------------------------------------------------------------------
shadedShpere1使用真实的顶点法向量和基于每个顶点的着色算法。
shadedShpere2使用真实的顶点法向量和基于每个片元的着色算法。
shadedShpere3和shadedShpere4使用每个三角形的三个顶点计算得到法向量，并分别采用基于每顶点和基于每片元的着色算法。

/**********************************************************************************************
shadedSphere1: shaded sphere using true normals and per vertex shading
物体，光源都不动，只有视点在极坐标表示的一个球面上动。
书6.9， 在shangder中，使用每个顶点的位置和法向量，光源，观察方向计算顶点颜色，生成明暗球体。
        界面交互控制视点的位置变化，交互控制递归细分次数。初始是一个四面体。基于 gouraud着色
shadedSphere1: shaded sphere using true normals and per vertex shading
交互界面：递归细分四面体生成球体。上面两排6个参数是增减视点位置的参数，第三排是增减细分次数的按钮  
顶点位置计算：APP中生成模视变换矩阵(只有视点变换)，投影矩阵作为公共变量传给顶点着色器
面着色计算：shader中，根据传入的顶点位置和法向量，原点为视点，计算顶点颜色，
            类似gouraud着色法，根据顶点位置法向量等计算颜色，再插值渲染整个面（本例颜色一致）
存在问题：APP传递的观察变换，shader中对顶点和法向量计算光照时用了两次？？？,修改后没有太大问题
*************************************************************************************************/

/****************************************************************************************
shadedSphere2: shaded sphere using true normals and per fragment shading
使用每像素着色，生成明暗球体，在fragment shader中计算颜色, 基于Phong着色
书6.10， 基于每个片元的光照计算。
*****************************************************************************************/

/**************************************************************************
shadedSphere3: shaded sphere using vertex normals and per vertex shading
使用顶点法向量和每顶点着色，生成明暗球体
注意和shadedSphere1的区别：triangle函数是不同的. 
3是计算出每个面的面法向量作为三个顶点的法向量，而1直接用顶点坐标。
效果上看，3的边界（即马赫带）更加明显，而1的不明显，1真实感更好一些。
***************************************************************************/

/**************************************************************************
shadedSphere4: shaded sphere using vertex normals and per fragment shading
使用顶点法向量和每像素着色，生成明暗球体
注意：是2 和3 的结合。马赫带明显，颜色真实感强。没有用顶点坐标作法向量
      采用3面法向量作顶点向量面颜色同，2的phong每片元计算颜色
***************************************************************************/



----------------------------------------------------------------------------------------------------------------
shadedSphereEyeSpace and shadedSphereObjectSpace show how lighting computations can be carried out in these spaces
光照着色计算 分别 在球眼空间 和 对象空间  进行 。
都是采用vertext shader中计算光照，只是一个是在WC下(这里的对象坐标），一个是在VC下计算（这里的眼坐标）
/***因为at总是WC下原点，它和POS和观察者位置总是在一条线上，所以这里是简化计算的方法*/


